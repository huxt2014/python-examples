
"""
    The core of SQLAlchemy's query and object mapping operations are supported
by database metadata, which is comprised of Python objects that describe tables
and other schema-level objects. These objects are at the core of three major
types of operations: SQL DDL, constructing SQL queries, and expressing
information about structures that already exist within the database.
    Database metadata can be expressed by explicitly naming the various
components and their properties. It can also be generated by SQLAlchemy using a
process called reflection
    A key feature of SQLAlchemy's database metadata constructs is that they are
designed to be used in a declarative style.

thread safety
    MetaData is a thread-safe object for read operations. Construction of new 
tables within a single MetaData object, either explicitly or via reflection, may
not be completely thread-safe.

"""

from datetime import datetime

from sqlalchemy import (MetaData, Table, Column, Integer, String, DateTime,
                        func, text, PickleType, create_engine, ForeignKey,
                        ForeignKeyConstraint, PrimaryKeyConstraint, Index)
from sqlalchemy.engine import reflection

metadata = MetaData()
engine = create_engine('db_url')

###############################################################################
#                          describe explicitly
# To represent a table, use the Table class. Its two primary arguments are the
# table name, then the MetaData object which it will be associated with. The
# remaining positional arguments are mostly Column objects describing each
# column.

# kwargs for Table
# schema: The schema name for this table, which is required if the table resides
#         in a schema other than the default selected schema for the engine's
#         database connection.
###############################################################################

# basic describe #######################################

user = Table('user', metadata, 
             Column('id', Integer, primary_key=True),    # primary key
             Column('name', String(16)),
             )

# primary key
user1 = Table('user', metadata,
              Column('id', Integer),
              Column('name', String(16)),
              PrimaryKeyConstraint('id')
              )

# foreign key
address = Table('address', metadata,
                Column('id', Integer, primary_key=True),
                Column('user_id', Integer, ForeignKey('user.id'))
                )

address1 = Table('address', metadata,
                 Column('id', Integer, primary_key=True),
                 Column('user_id', Integer),
                 ForeignKeyConstraint(('user_id',), ('user.id',))
                 )

# index
user2 = Table('user', metadata,
              Column('id', Integer, primary_key=True),
              Column('name', String(16), index=True),
              )

Index('ix_name', user2.c.name)

user3 = Table('user', metadata,
              Column('id', Integer, primary_key=True),
              Column('name', String(16), index=True),
              Index('ix_name', 'name')
              )

# describe dynamically ####################################
user.append_column(Column('user_id', Integer, primary_key=True))
user.append_constraint(Index('ix_name', 'name'))


# describe column default value ###########################

# scalar default
Column('c1', Integer, defalut=12),

# function default
Column('create_at', DateTime, default=datetime.now)

# update default
Column('last_modify_at', DateTime, onupdate=datetime.now)


# context-sensitive function
def my_default(context):
    return context.current_parameters['counter'] + 12

Column('counter_plus_twelve', Integer, default=my_default)

# SQL expressions - function
Column('create_at', DateTime, default=func.now())

# SQL expressions - subquery
Column('key', String(20),
       default=user.select(user.c.type == 'type1', limit=1))

# server side default
Column('created_at', DateTime, server_default=text("sysdate"))


# dialect #################################################
from sqlalchemy.dialects.mysql import (VARCHAR, INTEGER, DATETIME, BOOLEAN,
                                       TEXT, ENUM)
Column('created_at', DATETIME)
Column('c1', VARCHAR(64))
Column('c2', INTEGER)
Column('c3', TEXT)
Column('c4', BOOLEAN)
Column('c5', ENUM('v1', 'v2'))


# other ###################################################

# dumps automatically
Column('c', PickleType)


###############################################################################
#                          reflect database object
#     Reflection process only get the table schema that stored in the database.
# But some aspects of a schema may not be stored in database.
#     Reflect view is supported
###############################################################################

# auto load ###############################################
#     Send reflection queries and create table automatically
# when the first time accessing the table that not exists
# in metadata. The dependent tables will be loaded too.

# base auto load
user = Table('user', metadata, autoload=True)

# override a column when auto load
user4 = Table('user', metadata,
              Column('id', Integer, primary_key=True),      #
              autoload=True)

# reflect all tables at once ##############################
metadata.reflect(bind=engine, views=True)


###############################################################################
#                            inspect metadata
###############################################################################

# metadata ############################################

# get tables as list
for t in metadata.sorted_tables:
    print(t.name)

# get table name and table as dict-like object
for table_name, table in metadata.tables.iteritems():
    print(table_name, table)

# table ###############################################
# get columns
print(user.columns.user_id)
print(user.c.user_id)
print(user.c['user_id'])

for c in user.c:
    print(c)

# get foreign keys
for fkey in user.foreign_keys:
    print(fkey)


# column ##############################################
# inspect column property
print(user.c.user_id.name)
print(user.c.user_id.type)
print(user.c.user_id.nullable)


# a low level interface ###############################
insp = reflection.Inspector.from_engine(engine)
print(insp.get_table_names())
print(insp.get_view_names())

insp.get_columns('table_name')


###############################################################################
#                            operate database
###############################################################################

# create and drop all
metadata.create_all(engine)
metadata.drop_all(engine, checkfirst=True)

# create and drop one table, without other dependent table
user.create(engine, checkfirst=True)    # not create if exists
user.drop(engine)


'''
# customize DDL #############################################
event.listen(metadata, 'after_create',
             DDL("alter table ..."))

evemt.listen(metadata, 'after_create',
             DDL('alter table ...').execute_if(dialect='postgresql'))

'''
