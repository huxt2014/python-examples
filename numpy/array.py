

"""
General
    All ndarrays are homogenous: every item takes up the same size block of
memory, and all blocks are interpreted in exactly the same way. If you specify
different types in the list, NumPy will try to coerce all the items to the same
type.
    A dtype object describes how the bytes in the fixed-size block of memory
corresponding to an array item should be interpreted.
    An item extracted from an array will be a Python object whose type is the
scalar type associated with the dtype of the array. Note that the scalar types
are not dtype objects, even though they can be used in place of one whenever a
data type specification is needed in Numpy.

Reshape
    
"""
import numpy as np

###############################################################################
#                                  Construct
###############################################################################
# from list, get 1-d array
arr = np.array([1, 2, 3, 4], np.int)

# from nested list, get 2-d array
arr2 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], np.int)

# from built-in function
arr3 = np.zeros(shape=(2, 3), dtype=np.int)
arr4 = np.arange(15)                        # similar to range()

###############################################################################
#                                  inspect
###############################################################################
# number of element
assert arr.size == 4
assert np.size(arr2, 0) == arr2.shape[0]

# the type
print arr.dtype

# get the buff object
buff_obj = arr.data

###############################################################################
#                               reshape and resize
###############################################################################
# 1-d array to 2-d array
view_1 = arr.reshape(2, 2)

# 2-d array to 1-d array
view_2 = view_1.ravel()

# 2-d array to 1-d array
new_arr = view_1.flatten()

arr.shape = (2, 2)


###############################################################################
#                          vectorization and ufunc
#     vectorization of arithmetic operation and assignment for the same shape
# arrays
#     A universal function  is a function that operates on ndarrays in an
# element-by-element fashion. It supports array broadcasting, type casting, and
# several other standard features. ufunc instances can also be produced using
# the frompyfunc factory function.
###############################################################################

arr5 = np.array([1, 4, 9, 16])
arr6 = np.array([1, 3, 5, 7])
arr7 = np.array([[2, 3, 4, 5],
                 [3, 4, 5, 6]])

arr5*arr6                   # get [1,12,45,112]]
arr5 == arr6                # get [True, False, False, False]
arr5[1:] = arr6[1:]

np.vectorize(lambda x: x > 4)(arr5)

# ufunc ########################################################
# vectorization
np.sqrt(arr5)                 # get [1,2,3, 4]
np.maximum(arr5, arr6)        # get [1,4,9,16]
np.mod(arr5, arr6)            # get [0,1,4,2]
# broadcast
np.mod(arr7, arr6)            # get [[0,0,4,5],[0,1,0,6]]

###############################################################################
#                                  broadcast
###############################################################################

arr5*2           # get [1,4,6,8]
arr5+2           # get [3,4,5,6]
arr5 == 1        # get [True, False, False, False]


###############################################################################
#                             index and slice - arr[obj] 
#     Basic indexing/slicing occurs when obj is a slice object, an integer, or a
# tuple of slice objects and integers. Index will reduce one dimension. All
# arrays generated by basic indexing/slicing are always views of the original
# array, not copy.
#     Advanced indexing is triggered when obj is a non-tuple sequence, an
# ndarray, or a tuple with at list one non-tuple sequence or ndarray. Advanced
# indexing always returns a copy of the data.
#     Boolean indexing is a kind of advanced indexing.
###############################################################################

# shape of (2,2,4)
arr_3d = np.array([[[1, 2, 3, 4],
                    [5, 6, 7, 8]],
                   [[9, 10, 11, 12],
                    [13, 14, 15, 16]]])

# basic slicing ##################################################

# index by integer, get [[1,2,3,4], [5,6,7,8]]
assert arr_3d[0].shape == (2, 4)

# index by tuple of integer, get [1,2,3,4]
assert arr_3d[0, 0].shape == (4,)

# a tuple of slice objects and integers
# get [[5,6,7,8], [13,14,15,16]]
assert arr_3d[:, 1, :].shape == (2, 4)

# get [[6,7],[14,15]]
assert arr_3d[:, 1, 1:3].shape == (2, 2)

# get [[[13,14,15,16]]]
assert arr_3d[1:2, 1:2].shape == (1, 1, 4)

# Advanced indexing ##############################################

# integer array indexing
assert arr_3d[[0, 1]].shape == (2, 2, 4)     # select on axis 1

# tuple of integer array indexing
# the following means: [arr_3d[0, 0], arr_3d[1, 1]]
# get [[1, 2, 3, 4], [13, 14, 15, 16]]
assert arr_3d[[0, 1], [0, 1]].shape == (2, 4)

# the following means:  [arr_3d[0, 0, 0], arr_3d[1, 1, 1]]
assert arr_3d[[0, 1], [0, 1], [0, 1]].shape == (2,)

# broadcast will apply
# the following means: [arr_3d[0, 0, 0], arr_3d[1, 1, 0]]
assert arr_3d[[0, 1], [0, 1], 0].shape == (2,)
assert arr_3d[[0, 1], [0, 1], [0]].shape == (2,)

# high dimension array as index
# the following means [[arr_3d[0, 1], arr_3d[0, 1]],
#                      [arr_3d[1, 0], (arr_3d[1, 0]]]
assert arr_3d[[[0, 0], [1, 1]], [[1, 1], [0, 0]]].shape == (2, 2, 4)

###############################################################################
#                              stack and split
###############################################################################

arr1 = np.arange(9).reshape(3, 3)
arr2 = (arr1 + 1) * 10

assert np.hstack((arr1, arr2)).shape == (3, 6)
assert np.concatenate((arr1, arr2), axis=1).shape == (3, 6)

np.hsplit(arr1, 3)

###############################################################################
#                                   transpose
#     For a 1-D array, this has no effect. For a 2-D array, this is the usual
# matrix transpose. For an n-D array, if axes are given, their order indicates
# how the axes are permuted.
###############################################################################

arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
arr.transpose(1, 0)          # get [[1,5],[2,6],[3,7],[4,8]]

arr = np.array(
[[[1, 1, 1, 1],
 [2, 2, 2, 2],
 [3, 3, 3, 3]],

[[4, 4, 4, 4],
 [5, 5, 5, 5],
 [6, 6, 6, 6]]])

arr.transpose(1,0,2)
[[[1, 1, 1, 1],
  [4, 4, 4, 4]],

 [[2, 2, 2, 2],
  [5, 5, 5, 5]],

 [[3, 3, 3, 3],
  [6, 6, 6, 6]]]






