

'''
General
    All ndarrays are homogenous: every item takes up the same size block of
memory, and all blocks are interpreted in exactly the same way. 
    A dtype object describes how the bytes in the fixed-size block of memory
corresponding to an array item should be interpreted.
    An item extracted from an array will be a Python object whose type is the
scalar type associated with the dtype of the array. Note that the scalar types
are not dtype objects, even though they can be used in place of one whenever a
data type specification is needed in Numpy.

Reshape
    
'''
import numpy as np


#Construct
arr = np.array([1,2,3,4], np.int)                # 1-d array
arr = np.array([[1,2,3,4], [5,6,7,8]], np.int)   # nested list as 2-d array
arr = np.zeros(shape=(2,3), dtype=np.int)        #
arr = np.arange(15)                              # similar to range()


# vectorization of arithmetic operation and assignment for the same shape arrays
arr1 = np.array([1,2,3,4])
arr2 = np.array([1,3,5,7])
arr1*arr2                   # get [1,6,15,28]]
arr1 == arr2                # get [True, False, False, False]
arr1[1:] = arr2[1:]


# broadcast
arr1*2           # get [1,4,6,8]
arr1+2           # get [3,4,5,6]
arr1 == 1        # get [True, False, False, False]

###############################################################################
#                             index and slice - arr[obj] 
#     Basic slicing occurs when obj is a slice object, an integer, or a tuple of
# slice objects and integers. Index will reduce one dimension. All arrays
# generated by basic slicing are always views of the original array, not copy.
#     Advanced indexing is triggered when obj is a non-tuple sequence, an
# ndarray, or a tuple with at list one non-tuple sequence or ndarray. Advanced
# indexing always returns a copy of the data.
#     Boolean indexing is a kind of advanced indexing.
###############################################################################

# basic slice
arr = np.array([[[1,2,3,4], [5,6,7,8]],
                [[9,10,11,12], [13,14,15,16]]
                ])    # shape of (2,2,4)
arr[0]                # get [[1,2,3,4], [5,6,7,8]], shape of (2,4)
arr[0,0]              # get [1,2,3,4], shape of (4,)
arr[:,1,:]            # get [[5,6,7,8], [13,14,15,16]], shape of [2,4]
arr[:, 1, 1:3]        # get [[6,7],[14,15]], shape of (2,2)
arr[1:2, 1:2]         # get [[[13,14,15,16]]], shape of (1,1,4)

###############################################################################
#                                   transpose
#     For a 1-D array, this has no effect. For a 2-D array, this is the usual
# matrix transpose. For an n-D array, if axes are given, their order indicates
# how the axes are permuted.
###############################################################################

arr = np.array([[1,2,3,4],[5,6,7,8]])
arr.transpose(1,0)          # get [[1,5],[2,6],[3,7],[4,8]]

arr = np.array(
[[[1, 1, 1, 1],
 [2, 2, 2, 2],
 [3, 3, 3, 3]],

[[4, 4, 4, 4],
 [5, 5, 5, 5],
 [6, 6, 6, 6]]])

arr.transpose(1,0,2)
[[[1, 1, 1, 1],
  [4, 4, 4, 4]],

 [[2, 2, 2, 2],
  [5, 5, 5, 5]],

 [[3, 3, 3, 3],
  [6, 6, 6, 6]]]

###############################################################################
#                                  ufunc
#     A universal function  is a function that operates on ndarrays in an 
# element-by-element fashion. It supports array broadcasting, type casting, and
# several other standard features.
#     ufunc instances can also be produced using the frompyfunc factory
# function.
###############################################################################
arr1 = np.array([1,4,9])
arr2 = np.array([2,3,4])
arr3 = np.array([[2,3,4],[3,4,5]])
np.sqrt(arr1)                   # get [1,2,3]
np.maximum(arr1, arr2)          # get [2,4,9]
np.mod(arr1, arr2)              # get [1,1,1]
np.mod(arr3, arr2)              # get [[0,0,0],[1,1,1]]


