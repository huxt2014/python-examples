

"""
    The SQLAlchemy Expression Language presents a system of representing 
relational database structures and expressions using Python constructs. Also, 
it presents a method of writing backend-neutral SQL expressions.
    The SQLAlchemy ORM, which is built on the top of the Expression Language, 
show an example of applied usage of the Expression Language. Most of the query
begin with session.query() which return an Query object.
    The class Query features a generative interface whereby successive calls 
return a new Query object, a copy of the former with additional criteria and 
options associated with it.
    These constructs usually represent SQL as intermediate format. When bind 
with an engine, the ultimate SQL can be generated with the help of dialect.
"""

from sqlalchemy import (Column, Integer, String, ForeignKey, create_engine,
                        text, func, desc, and_, or_, not_)
from sqlalchemy.orm import Query
from sqlalchemy.orm.session import Session
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import (select, case, bindparam, union, except_)

Base = declarative_base()
meta = Base.meta
engine = create_engine('db_url')
session = Session(bind=engine)


class User(Base):
    __tablename__ = 'user'
    id = Column(Integer, primary_key=True)
    name = Column(String(16))


class Address(Base):
    __tablename__ = 'address'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('user.id'))
    email_address = Column(String)

user = User.__table__
address = Address.__table__
con = engine.connect()

###############################################################################
#                         ORM-level SQL construction                                   
#     Query is the source of all SELECT statements generated by the ORM.  It
# features a generative interface whereby successive calls return a new Query 
# object, a copy of the former with additional criteria and options associated
# with it.
#     Query objects are normally initially generated using the query() method
# of Session. 
#     query() takes a variable number of arguments, any combination of mapped  
# class, a Mapper object, an orm-enabled descriptor, or an AliasedClass object.
###############################################################################

# basic query #############################################

# select
query = Query(User)

# insert
session.add(User(id=1))

# aggregation
(Query(User.department.
       func.sum(User.salary).albel('salary'),
       func.count('*').label('total_number'))
 .group_by(User.department))

# case
Query(User.id,
      case([(User.salary < 1000, 1),
            (User.salary.between(1000,2000), 2)],
           else_=0).label('salary'))


# join #####################################################

# implicit join apply a cross join that get the Cartesian
# product.
Query(User, Address)                  # return tow instances
Query(User.name, Address.location)    # return two columns
Query(User, Address.location)         # return an instance and an column

# explict join apply a inner join. If only one foreign key
# exists between them, an on clause will be applied
# automatically (with poor readability).
Query(User).join(Address)             # return User only
Query(User).join(Address, User.id == Address.user_id)  # using condition

# explict join using relationship
Query(User).join(User.addresses)
Query(User).join('addresses')
Query(User).join(Address, User.addresses)

# In join query, table on the left side of the join is decided
# by the leftmost entity in the Query object's list of
# entities by default. Use select_from() to specify a table.
Query(User, Address).select_from(User).join(User.addresses)

# filter and filter_by, can be chained.
query.filter_by(id=1)                  # uses keyword arguments
query.filter(User.id == 1)             # use SQL expression object
query.filter(text("id<10"))            # use textual SQL
(query.filter(text("id<:value and name=:name"))   # bind parameters
      .params(value=10, name='hello'))

# other option
query.order_by(User.id)
query.distinct()
query.limit()
query.offset()


# emit query and get result #################################

# the select Query instance will not emit a query until the
# following method invoked
query.all()              # fetch all as list
query.first()            # fetch one or None
query.one()              # fetch one or NoResultFound or MultipleResultsFound
query.one_or_none()      # fetch one or None or MultipleResultsFound
query.scalar()           # invokes the one() method and return the first column
result = query[1:3]      # list with limit and offset


# batch operator #########################################
# batch update and delete will emit the query immediately,
# return the number of row that changed.
changed_number = (Query(User)
                  .filter_by(name='a')
                  .update({User.name: 'b'}, synchronize_session=False))

delete_number = Query(User).filter_by(ID=6).delete()

# sub-query ##############################################
# use sub-query, act as mapped class
sub_q = (Query(User.id, func.count('*').label('num'))
         .select_from(User, Address)
         .group_by(User.id)
         .subquery())
Query(sub_q.id, sub_q.num)


###############################################################################
#                          using expression language                          #
#     The term "selectable" refers to any object that rows can be selected from.
# Usually, it is generated from  FromClause.select() or select(). FromClause 
# instance typically refer to Table instance or Alias object.
#     The select() receive a list of ColumnElement object, FromCllause object or
# Text constructs. For FromClause object, the FromClause.c collection is 
# extracted to form a collection of ColumnElement objects.  
###############################################################################

# insert ######################################################

# construct a insert query, and limit columns using values. The
# actual data is not rendered into the sql, until the statement
# is executed.
ins = user.insert().values(name='name', email='email')
result2 = con.execute(ins)

# The insert statement is compiled at execution time based on
# the parameters.
ins = user.insert()
con.execute(ins, name='', email='')

# To issue many inserts using DBAPI's executemany() method. Each
# dictionary must have the same set of keys, because the Insert
# statement is compiled against the first dictionary in the list.
con.execute(user.insert(), [{'name': 'name1', 'email': 'email1'},
                            {'name': 'name2', 'email': 'email2'}])


# select #######################################################

# table object will be expanded to columns
sel = select([user])
sel2 = address.select()

# select several columns
select([user.c.name, user.c.email])

# label
select([user.c.id.label('user_id')])

# where
select([user, address]).where(user.c.id == address.c.user_id)


# order
select([user]).order_by('id')
select([user]).order_by(user.c.id)
select([user]).order_by(desc('id'))
select([user]).order_by(user.c.id.asc())


# join #########################################################

# join implicitly, get all columns.
select([user, address])

# explicitly join
select([user.c.name]).select_from(user.join(address))

# join on foreign keys if only one relationship exists
user.join(address)

# specify on clause
user.join(address,
          address.c.user_id > 5)


# set operations ###############################################
u = union(address.select().where(),
          address.select().where(),
          ).order_by(address.c.email_address)


# result #######################################################
# The result, known as a ResultProxy object, is analogous to the
# DBAPI cursor object.

result3 = con.execute(sel)

result.fetchone()
result.fetchall()

for row in result:
    print row
    print row['name'], row['email']
    print row[0], row[1]
    print row[user.c.name], row[user.c.email]

# Implicit Execution ###########################################
#     Implicit execution is also connectionless, but it is a
# very old usage pattern that in most cases is more confusing
# than it is helpful, and its usage is discouraged.

# bind the engine
meta.bind = engine
result = user.select().execute()

# Result sets which have pending rows remaining should be
# explicitly closed before discarding.
result.close()

###############################################################################
#                               column operators
###############################################################################

# simple
select([user.c.id + user.c.id,
        func.now(),                         # select now()
        func.any_func()])                   # select any_func()


(select([user, address])
 .where(user.c.id == 7)
 .where(user.c.id == address.c.user_id)
 .where(user.c.id != 7)
 .where(~(user.c.id == 7))
 .where(not_(user.c.id == 1))
 .where(user.c.id > 7)
 .where(user.c.name.like('John%'))
 .where(user.c.name.between(1, 10))
 .where(user.c.name.is_(None))
 .where(user.c.name.isnot(None))
 .where(user.c.id.in_([1, 2, 3]))
 .where(user.c.id.notin_([1, 2, 3]))
 )

# conjunction
cond = ((user.c.id == 1)
        & (user.c.id == 1)                         # and
        & ((user.c.id == 1) | (user.c.id == 1))    # or
        & ~(user.c.id > 5)                         # not
        )

and_(user.c.id == 1, user.c.id == 1)               # and
or_(user.c.id == 1, user.c.id == 1)                # or


# textual SQL ###########################################

# basic
s = text(
     "SELECT user.fullname, address.email_address AS title "
     "FROM user, address "
     "WHERE user.id = address.user_id "
     "  AND user.name BETWEEN :x AND :y "
     "  AND (address.email_address LIKE :e1 "
     "       OR address.email_address LIKE :e2)")

con.execute(s, x='m', y='z', e1='%@aol.com', e2='%@msn.com').fetchall()

# bind
text('select ...').bindparams(x='', y='')              # simple
text('select ...').bindparams(bindparam('x', String))  # bind with type
